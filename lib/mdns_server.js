// Generated by CoffeeScript 1.3.3
(function() {
  var NS_C_IN, NS_RCODE_NXDOMAIN, NS_T_A, dnsserver, exec, mDnsServer, util,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  dnsserver = require("dnsserver");

  util = require("util");

  exec = require("child_process").exec;

  NS_T_A = 1;

  NS_C_IN = 1;

  NS_RCODE_NXDOMAIN = 3;

  module.exports = mDnsServer = (function(_super) {
    var lookupAddressToContactAddressPattern, lookupAddressToContactInterfacePattern;

    __extends(mDnsServer, _super);

    function mDnsServer(configuration) {
      this.configuration = configuration;
      this.handleRequest = __bind(this.handleRequest, this);

      mDnsServer.__super__.constructor.apply(this, arguments);
      this.on("request", this.handleRequest);
    }

    mDnsServer.prototype.lookupHostname = function(callback) {
      var _this = this;
      if (this.configuration.mDnsHost !== null) {
        return typeof callback === "function" ? callback(null, this.configuration.mDnsHost) : void 0;
      } else {
        return exec("scutil --get LocalHostName", function(error, stdout, stderr) {
          var hostname;
          if (error) {
            return typeof callback === "function" ? callback(error) : void 0;
          }
          hostname = stdout.trim();
          return typeof callback === "function" ? callback(null, hostname) : void 0;
        });
      }
    };

    lookupAddressToContactInterfacePattern = /interface:\s+(\S+)/i;

    lookupAddressToContactAddressPattern = /inet\s+(\d+\.\d+\.\d+\.\d+)/i;

    mDnsServer.prototype.lookupAddressToContact = function(address, callback) {
      var _this = this;
      return exec("/sbin/route get default", function(error, stdout, stderr) {
        var iface, _ref;
        iface = (_ref = stdout.match(lookupAddressToContactInterfacePattern)) != null ? _ref[1] : void 0;
        if (error || !iface) {
          return typeof callback === "function" ? callback(error) : void 0;
        }
        return exec("/sbin/ifconfig " + iface, function(error, stdout, stderr) {
          var myAddress, _ref1;
          myAddress = (_ref1 = stdout.match(lookupAddressToContactAddressPattern)) != null ? _ref1[1] : void 0;
          if (error || !myAddress) {
            return typeof callback === "function" ? callback(error) : void 0;
          }
          return typeof callback === "function" ? callback(null, myAddress) : void 0;
        });
      });
    };

    mDnsServer.prototype.listen = function(port, callback) {
      var _this = this;
      return this.lookupHostname(function(error, hostname) {
        var mDnsHost;
        if (error) {
          return typeof callback === "function" ? callback(error) : void 0;
        }
        _this.pattern = RegExp("(^|\\.)" + hostname + "\\." + _this.configuration.mDnsDomain + "\\.?", "i");
        _this.bind(_this.configuration.mDnsPort);
        _this.setMulticastLoopback(true);
        _this.addMembership(_this.configuration.mDnsAddress);
        mDnsHost = ("" + hostname + "." + _this.configuration.mDnsDomain).toLowerCase();
        _this.configuration.addToAllDomains(mDnsHost);
        return typeof callback === "function" ? callback() : void 0;
      });
    };

    mDnsServer.prototype.handleRequest = function(req, res) {
      var question,
        _this = this;
      if (!(req.header.qdcount > 0 && req.header.ancount < req.header.qdcount)) {
        return;
      }
      question = req.question;
      if (!(question.type === NS_T_A && question["class"] === NS_C_IN && this.pattern.test(question.name))) {
        return;
      }
      return this.lookupAddressToContact(res.rinfo.address, function(error, myAddress) {
        var buffer;
        if (error) {
          return;
        }
        res.addRR(question.name, NS_T_A, NS_C_IN, 600, myAddress);
        buffer = res.toBuffer();
        return res.socket.send(buffer, 0, buffer.length, _this.configuration.mDnsPort, _this.configuration.mDnsAddress);
      });
    };

    return mDnsServer;

  })(dnsserver.Server);

}).call(this);
